CVE-2018-1002200
plexus-archiver before 3.6.0 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in an archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.
{	    "affected_product": {	        "package_name": "plexus-archiver",	        "github_url": "",	        "fix_versions": ["3.6.0"],	        "affected_versions": ["<3.6.0"],	        "version_intervals": []	    },	    "related_products": [],	    "vulnerability_type": "directory traversal",	    "vulnerability_type_details": "Zip-Slip",	    "keywords": ["plexus-archiver", "directory traversal", "Zip-Slip"],	    "code_info": {	        "vulnerable_file_names": [],	        "vulnerable_function_names": [],	        "vulnerable_component_names": [],	        "exception_names": [],	        "vulnerable_code_lines": [],	        "vulnerable_command_names": [],	        "parameters": []	    },	    "exploit_info": {	        "proof_of_concept": "",	        "privileges_required": "",	        "exploit_maturity": ""	    },	    "other_info": {	        "workaround": "",	        "product_description": "",	        "component_additional_info": "",	        "is_cve_disputed": "",	        "is_cve_rejected": "",	        "referenced_cve": []	    }	}

CVE-2018-1002201
zt-zip before 1.13 is vulnerable to directory traversal, allowing attackers to write to arbitrary files via a ../ (dot dot slash) in a Zip archive entry that is mishandled during extraction. This vulnerability is also known as 'Zip-Slip'.
{	    "affected_product": {	        "package_name": "zt-zip",	        "github_url": "",	        "fix_versions": [],	        "affected_versions": ["before 1.13"],	        "version_intervals": []	    },	    "related_products": [],	    "vulnerability_type": "directory traversal",	    "vulnerability_type_details": "This vulnerability allows attackers to write to arbitrary files via a ../ in a Zip archive entry during extraction.",	    "keywords": ["zt-zip", "directory traversal", "Zip-Slip"],	    "code_info": {	        "vulnerable_file_names": [],	        "vulnerable_function_names": [],	        "vulnerable_component_names": [],	        "exception_names": [],	        "vulnerable_code_lines": [],	        "vulnerable_command_names": [],	        "parameters": []	    },	    "exploit_info": {	        "proof_of_concept": "",	        "privileges_required": "",	        "exploit_maturity": ""	    },	    "other_info": {	        "workaround": "",	        "product_description": "",	        "component_additional_info": "",	        "is_cve_disputed": "",	        "is_cve_rejected": "",	        "referenced_cve": []	    }	}

CVE-2018-1261
Spring-integration-zip versions prior to 1.0.1 exposes an arbitrary file write vulnerability, which can be achieved using a specially crafted zip archive (affects other archives as well, bzip2, tar, xz, war, cpio, 7z) that holds path traversal filenames. So when the filename gets concatenated to the target extraction directory, the final path ends up outside of the target folder.
{	  "affected_product": {	    "package_name": "Spring-integration-zip",	    "github_url": "",	    "fix_versions": [],	    "affected_versions": [],	    "version_intervals": []	  },	  "related_products": [],	  "vulnerability_type": "Arbitrary File Write",	  "vulnerability_type_details": "Path Traversal",	  "keywords": [	    "Spring-integration-zip",	    "arbitrary file write",	    "zip archive",	    "path traversal",	    "bzip2",	    "tar",	    "xz",	    "war",	    "cpio",	    "7z"	  ],	  "code_info": {	    "vulnerable_file_names": [],	    "vulnerable_function_names": [],	    "vulnerable_component_names": [],	    "exception_names": [],	    "vulnerable_code_lines": [],	    "vulnerable_command_names": [],	    "parameters": []	  },	  "exploit_info": {	    "proof_of_concept": "",	    "privileges_required": "",	    "exploit_maturity": ""	  },	  "other_info": {	    "workaround": "",	    "product_description": "",	    "component_additional_info": "",	    "is_cve_disputed": "",	    "is_cve_rejected": "",	    "referenced_cve": []	  }	}

CVE-2018-1263
Addresses partial fix in CVE-2018-1261. Pivotal spring-integration-zip, versions prior to 1.0.2, exposes an arbitrary file write vulnerability, that can be achieved using a specially crafted zip archive (affects other archives as well, bzip2, tar, xz, war, cpio, 7z), that holds path traversal filenames. So when the filename gets concatenated to the target extraction directory, the final path ends up outside of the target folder.
{	  "affected_product": {	    "package_name": "spring-integration-zip",	    "github_url": "",	    "fix_versions": ["1.0.2"],	    "affected_versions": ["<1.0.2"],	    "version_intervals": []	  },	  "related_products": [],	  "vulnerability_type": "arbitrary file write",	  "vulnerability_type_details": "",	  "keywords": ["arbitrary file write", "path traversal", "zip archive", "bzip2", "tar", "xz", "war", "cpio", "7z"],	  "code_info": {	    "vulnerable_file_names": [],	    "vulnerable_function_names": [],	    "vulnerable_component_names": ["spring-integration-zip"],	    "exception_names": [],	    "vulnerable_code_lines": [],	    "vulnerable_command_names": [],	    "parameters": []	  },	  "exploit_info": {	    "proof_of_concept": "",	    "privileges_required": "",	    "exploit_maturity": ""	  },	  "other_info": {	    "workaround": "",	    "product_description": "",	    "component_additional_info": "",	    "is_cve_disputed": "",	    "is_cve_rejected": "",	    "referenced_cve": ["CVE-2018-1261"]	  }	}

CVE-2018-8008
Apache Storm version 1.0.6 and earlier, 1.2.1 and earlier, and version 1.1.2 and earlier expose an arbitrary file write vulnerability, that can be achieved using a specially crafted zip archive (affects other archives as well, bzip2, tar, xz, war, cpio, 7z), that holds path traversal filenames. So when the filename gets concatenated to the target extraction directory, the final path ends up outside of the target folder.
{"affected_product": {	    "package_name": "Apache Storm",	    "github_url": "",	    "fix_versions": ["1.0.7", "1.2.2", "1.1.3"],	    "affected_versions": ["1.0.6", "1.2.1", "1.1.2"],	    "version_intervals" : []	},	"related_products": [],	"vulnerability_type": "Arbitrary File Write",	"vulnerability_type_details": "Path traversal vulnerability when extracting specially crafted zip archives",	"keywords": ["Apache Storm", "arbitrary file write", "zip archive", "path traversal", "vulnerability"],	"code_info": {	    "vulnerable_file_names" : [],	    "vulnerable_function_names": [],	    "vulnerable_component_names": [],	    "exception_names": [],	    "vulnerable_code_lines": [],	    "vulnerable_command_names": [],	    "parameters": []	},	"exploit_info": {	    "proof_of_concept": "",	    "privileges_required": "",	    "exploit_maturity": ""	},	"other_info": {	    "workaround": "",	    "product_description": "",	    "component_additional_info": "",	    "is_cve_disputed": "",	    "is_cve_rejected" : "",	    "referenced_cve": []	}	}

CVE-2019-10751
All versions of the HTTPie package prior to version 1.0.3 are vulnerable to Open Redirect that allows an attacker to write an arbitrary file with supplied filename and content to the current directory, by redirecting a request from HTTP to a crafted URL pointing to a server in his or hers control.
{	"affected_product": {	"package_name": "HTTPie",	"github_url": "",	"fix_versions": ["1.0.3"],	"affected_versions": ["<1.0.3"],	"version_intervals" : [ ]	},	"related_products": [ ],	"vulnerability_type": "Open Redirect",	"vulnerability_type_details": "Allows an attacker to write an arbitrary file with supplied filename and content to the current directory",	"keywords": ["HTTPie", "vulnerable", "Open Redirect", "arbitrary file", "current directory", "crafted URL"],	"code_info": {	"vulnerable_file_names" : [""],	"vulnerable_function_names": [""],	"vulnerable_component_names": [""],	"exception_names": [""],	"vulnerable_code_lines": [""],	"vulnerable_command_names": [""],	"parameters": [""]	},	"exploit_info": {	"proof_of_concept": "",	"privileges_required": "",	"exploit_maturity": ""	},	"other_info": {	"workaround": "",	"product_description": "",	"component_additional_info": "",	"is_cve_disputed": "",	"is_cve_rejected" : "",	"referenced_cve": []	}	}

CVE-2019-10754
Multiple classes used within Apereo CAS before release 6.1.0-RC5 makes use of apache commons-lang3 RandomStringUtils for token and ID generation which makes them predictable due to RandomStringUtils PRNG's algorithm not being cryptographically strong.
{	"affected_product": {	"package_name": "Apereo CAS",	"github_url": "",	"fix_versions": ["6.1.0-RC5"],	"affected_versions": ["<6.1.0-RC5"],	"version_intervals" : [  ]	},	"related_products": [ ],	"vulnerability_type": "Weak Cryptographic Algorithm",	"vulnerability_type_details": "apache commons-lang3 RandomStringUtils PRNG's algorithm not being cryptographically strong",	"keywords": ["Apereo CAS", "commons-lang3", "RandomStringUtils", "token generation", "ID generation", "predictable", "cryptographically strong"],	"code_info": {	"vulnerable_file_names" : [""],	"vulnerable_function_names": [""],	"vulnerable_component_names": ["apache commons-lang3 RandomStringUtils"],	"exception_names": [""],	"vulnerable_code_lines": [""],	"vulnerable_command_names": [""],	"parameters": [""]	},	"exploit_info": {	"proof_of_concept": "",	"privileges_required": "",	"exploit_maturity": ""	},	"other_info": {	"workaround": "",	"product_description": "",	"component_additional_info": "",	"is_cve_disputed": "",	"is_cve_rejected" : "",	"referenced_cve": []	}	}

CVE-2019-10770
All versions of io.ratpack:ratpack-core from 0.9.10 inclusive and before 1.7.6 are vulnerable to Cross-site Scripting (XSS). This affects the development mode error handler when an exception message contains untrusted data. Note the production mode error handler is not vulnerable - so for this to be utilized in production it would require users to not disable development mode.
{	    "affected_product": {	        "package_name": "io.ratpack:ratpack-core",	        "github_url": "",	        "fix_versions": [	            "1.7.6"	        ],	        "affected_versions": [	            "0.9.10",	            "1.7.5"	        ],	        "version_intervals": []	    },	    "related_products": [],	    "vulnerability_type": "Cross-site Scripting (XSS)",	    "vulnerability_type_details": "",	    "keywords": [	        "io.ratpack:ratpack-core",	        "Cross-site Scripting",	        "XSS",	        "development mode",	        "error handler",	        "exception message",	        "untrusted data"	    ],	    "code_info": {	        "vulnerable_file_names": [],	        "vulnerable_function_names": [],	        "vulnerable_component_names": [],	        "exception_names": [],	        "vulnerable_code_lines": [],	        "vulnerable_command_names": [],	        "parameters": []	    },	    "exploit_info": {	        "proof_of_concept": "",	        "privileges_required": "",	        "exploit_maturity": ""	    },	    "other_info": {	        "workaround": "",	        "product_description": "",	        "component_additional_info": "",	        "is_cve_disputed": "",	        "is_cve_rejected": "",	        "referenced_cve": []	    }	}

CVE-2019-10797
Netty in WSO2 transport-http before v6.3.1 is vulnerable to HTTP Response Splitting due to HTTP Header validation being disabled.
{	  "affected_product": {	    "package_name": "Netty in WSO2 transport-http",	    "github_url": "",	    "fix_versions": ["v6.3.1"],	    "affected_versions": [],	    "version_intervals": []	  },	  "related_products": [],	  "vulnerability_type": "HTTP Response Splitting",	  "vulnerability_type_details": "",	  "keywords": ["Netty", "WSO2", "transport-http", "vulnerable", "HTTP Response Splitting", "HTTP Header validation"],	  "code_info": {	    "vulnerable_file_names": [],	    "vulnerable_function_names": [],	    "vulnerable_component_names": [],	    "exception_names": [],	    "vulnerable_code_lines": [],	    "vulnerable_command_names": [],	    "parameters": []	  },	  "exploit_info": {	    "proof_of_concept": "",	    "privileges_required": "",	    "exploit_maturity": ""	  },	  "other_info": {	    "workaround": "",	    "product_description": "",	    "component_additional_info": "",	    "is_cve_disputed": "",	    "is_cve_rejected": "",	    "referenced_cve": []	  }	}

CVE-2019-17513
An issue was discovered in Ratpack before 1.7.5. Due to a misuse of the Netty library class DefaultHttpHeaders, there is no validation that headers lack HTTP control characters. Thus, if untrusted data is used to construct HTTP headers with Ratpack, HTTP Response Splitting can occur.
{	"affected_product": {	"package_name": "Ratpack",	"github_url": "",	"fix_versions": ["1.7.5"],	"affected_versions": [""],	"version_intervals" : []	},	"related_products": [],	"vulnerability_type": "HTTP Response Splitting",	"vulnerability_type_details": "",	"keywords": ["Ratpack", "Netty library", "DefaultHttpHeaders", "validation", "headers", "HTTP control characters", "untrusted data", "HTTP Response Splitting"],	"code_info": {	"vulnerable_file_names" : [],	"vulnerable_function_names": [],	"vulnerable_component_names": [],	"exception_names": [],	"vulnerable_code_lines": [],	"vulnerable_command_names": [],	"parameters": [],	},	"exploit_info": {	"proof_of_concept": "",	"privileges_required": "",	"exploit_maturity": ""	},	"other_info": {	"workaround": "",	"product_description": "",	"component_additional_info": "",	"is_cve_disputed": "",	"is_cve_rejected" : "",	"referenced_cve": []	}	}

CVE-2020-11981
An issue was found in Apache Airflow versions 1.10.10 and below. When using CeleryExecutor, if an attacker can connect to the broker (Redis, RabbitMQ) directly, it is possible to inject commands, resulting in the celery worker running arbitrary commands.
{	    "affected_product": {	        "package_name": "Apache Airflow",	        "github_url": "",	        "fix_versions": [],	        "affected_versions": ["1.10.10 and below"],	        "version_intervals" : []	    },	    "related_products": [],	    "vulnerability_type": "Command Injection",	    "vulnerability_type_details": "",	    "keywords": ["Apache Airflow", "CeleryExecutor", "broker", "Redis", "RabbitMQ", "command injection"],	    "code_info": {	        "vulnerable_file_names" : [],	        "vulnerable_function_names": [],	        "vulnerable_component_names": [],	        "exception_names": [],	        "vulnerable_code_lines": [],	        "vulnerable_command_names": [],	        "parameters": []	    },	    "exploit_info": {	        "proof_of_concept": "",	        "privileges_required": "",	        "exploit_maturity": ""	    },	    "other_info": {	        "workaround": "",	        "product_description": "",	        "component_additional_info": "",	        "is_cve_disputed": "",	        "is_cve_rejected" : "",	        "referenced_cve": []	    }	}

CVE-2020-15250
In JUnit4 from version 4.7 and before 4.13.1, the test rule TemporaryFolder contains a local information disclosure vulnerability. On Unix like systems, the system's temporary directory is shared between all users on that system. Because of this, when files and directories are written into this directory they are, by default, readable by other users on that same system. This vulnerability does not allow other users to overwrite the contents of these directories or files. This is purely an information disclosure vulnerability. This vulnerability impacts you if the JUnit tests write sensitive information, like API keys or passwords, into the temporary folder, and the JUnit tests execute in an environment where the OS has other untrusted users. Because certain JDK file system APIs were only added in JDK 1.7, this this fix is dependent upon the version of the JDK you are using. For Java 1.7 and higher users: this vulnerability is fixed in 4.13.1. For Java 1.6 and lower users: no patch is available, you must use the workaround below. If you are unable to patch, or are stuck running on Java 1.6, specifying the `java.io.tmpdir` system environment variable to a directory that is exclusively owned by the executing user will fix this vulnerability. For more information, including an example of vulnerable code, see the referenced GitHub Security Advisory.
{	"affected_product": {	"package_name": "JUnit",	"github_url": "",	"fix_versions": ["4.13.1"],	"affected_versions": ["4.7 - 4.13.1"],	"version_intervals" : []	},	"related_products": [],	"vulnerability_type": "Information disclosure",	"vulnerability_type_details": "",	"keywords": ["JUnit4", "test rule", "TemporaryFolder", "local information disclosure vulnerability", "Unix like systems", "temporary directory", "information disclosure", "vulnerable code"],	"code_info": {	"vulnerable_file_names" : [],	"vulnerable_function_names": [],	"vulnerable_component_names": ["JUnit4", "TemporaryFolder"],	"exception_names": [],	"vulnerable_code_lines": [],	"vulnerable_command_names": [],	"parameters": []	},	"exploit_info": {	"proof_of_concept": "",	"privileges_required": "",	"exploit_maturity": ""	},	"other_info": {	"workaround": "Specify the `java.io.tmpdir` system environment variable to a directory that is exclusively owned by the executing user.",	"product_description": "",	"component_additional_info": "",	"is_cve_disputed": "",	"is_cve_rejected" : "",	"referenced_cve": []	}	}

CVE-2020-28491
This affects the package com.fasterxml.jackson.dataformat:jackson-dataformat-cbor from 0 and before 2.11.4, from 2.12.0-rc1 and before 2.12.1. Unchecked allocation of byte buffer can cause a java.lang.OutOfMemoryError exception.
{	    "affected_product": {	        "package_name": "com.fasterxml.jackson.dataformat:jackson-dataformat-cbor",	        "github_url": "",	        "fix_versions": ["2.11.4", "2.12.1"],	        "affected_versions": ["0", "2.12.0-rc1"],	        "version_intervals": []	    },	    "related_products": [],	    "vulnerability_type": "Unchecked Allocation",	    "vulnerability_type_details": "",	    "keywords": ["package", "com.fasterxml.jackson.dataformat:jackson-dataformat-cbor", "0", "2.11.4", "2.12.0-rc1", "Unchecked Allocation", "java.lang.OutOfMemoryError"],	    "code_info": {	        "vulnerable_file_names": [],	        "vulnerable_function_names": [],	        "vulnerable_component_names": [],	        "exception_names": ["java.lang.OutOfMemoryError"],	        "vulnerable_code_lines": [],	        "vulnerable_command_names": [],	        "parameters": []	    },	    "exploit_info": {	        "proof_of_concept": "",	        "privileges_required": "",	        "exploit_maturity": ""	    },	    "other_info": {	        "workaround": "",	        "product_description": "",	        "component_additional_info": "",	        "is_cve_disputed": "",	        "is_cve_rejected": "",	        "referenced_cve": []	    }	}

CVE-2020-28493
This affects the package jinja2 from 0.0.0 and before 2.11.3. The ReDoS vulnerability is mainly due to the `_punctuation_re regex` operator and its use of multiple wildcards. The last wildcard is the most exploitable as it searches for trailing punctuation. This issue can be mitigated by Markdown to format user content instead of the urlize filter, or by implementing request timeouts and limiting process memory.
{	  "affected_product": {	    "package_name": "jinja2",	    "github_url": "",	    "fix_versions": ["2.11.3"],	    "affected_versions": ["0.0.0"],	    "version_intervals": []	  },	  "related_products": [],	  "vulnerability_type": "ReDoS",	  "vulnerability_type_details": "",	  "keywords": ["package", "jinja2", "vulnerability", "ReDoS", "_punctuation_re regex", "wildcards", "trailing punctuation", "Markdown", "urlize filter", "request timeouts", "process memory"],	  "code_info": {	    "vulnerable_file_names": [],	    "vulnerable_function_names": [],	    "vulnerable_component_names": [],	    "exception_names": [],	    "vulnerable_code_lines": [],	    "vulnerable_command_names": [],	    "parameters": []	  },	  "exploit_info": {	    "proof_of_concept": "",	    "privileges_required": "",	    "exploit_maturity": ""	  },	  "other_info": {	    "workaround": "Mitigate by using Markdown to format user content instead of the urlize filter, or by implementing request timeouts and limiting process memory.",	    "product_description": "",	    "component_additional_info": "",	    "is_cve_disputed": "",	    "is_cve_rejected": "",	    "referenced_cve": []	  }	}

CVE-2020-7611
All versions of io.micronaut:micronaut-http-client before 1.2.11 and all versions from 1.3.0 before 1.3.2 are vulnerable to HTTP Request Header Injection due to not validating request headers passed to the client.
{	    "affected_product": {	        "package_name": "io.micronaut:micronaut-http-client",	        "github_url": "",	        "fix_versions": ["1.2.11", "1.3.2"],	        "affected_versions": ["<1.2.11", ">=1.3.0, <1.3.2"],	        "version_intervals": []	    },	    "related_products": [],	    "vulnerability_type": "HTTP Request Header Injection",	    "vulnerability_type_details": "",	    "keywords": ["io.micronaut", "micronaut-http-client", "vulnerable", "HTTP Request Header Injection", "request headers", "client"],	    "code_info": {	        "vulnerable_file_names": [],	        "vulnerable_function_names": [],	        "vulnerable_component_names": [],	        "exception_names": [],	        "vulnerable_code_lines": [],	        "vulnerable_command_names": [],	        "parameters": []	    },	    "exploit_info": {	        "proof_of_concept": "",	        "privileges_required": "",	        "exploit_maturity": ""	    },	    "other_info": {	        "workaround": "",	        "product_description": "",	        "component_additional_info": "",	        "is_cve_disputed": "",	        "is_cve_rejected": "",	        "referenced_cve": []	    }	}

CVE-2020-7622
This affects the package io.jooby:jooby-netty before 1.6.9, from 2.0.0 and before 2.2.1. The DefaultHttpHeaders is set to false which means it does not validates that the header isn't being abused for HTTP Response Splitting.
{	"affected_product": {	"package_name": "io.jooby:jooby-netty",	"github_url": "",	"fix_versions": ["1.6.9", "2.0.0", "2.2.1"],	"affected_versions": ["before 1.6.9", "from 2.0.0 and before 2.2.1"],	"version_intervals" : []	},	"related_products": [],	"vulnerability_type": "HTTP Response Splitting",	"vulnerability_type_details": "",	"keywords": ["package", "io.jooby:jooby-netty", "1.6.9", "2.0.0", "2.2.1", "DefaultHttpHeaders", "abused", "HTTP Response Splitting"],	"code_info": {	"vulnerable_file_names" : [],	"vulnerable_function_names": [],	"vulnerable_component_names": [],	"exception_names": [],	"vulnerable_code_lines": [],	"vulnerable_command_names": [],	"parameters": [],	},	"exploit_info": {	"proof_of_concept": "",	"privileges_required": "",	"exploit_maturity": ""	},	"other_info": {	"workaround": "",	"product_description": "",	"component_additional_info": "",	"is_cve_disputed": "",	"is_cve_rejected" : "",	"referenced_cve": []	}	}

CVE-2020-7655
netius prior to 1.17.58 is vulnerable to HTTP Request Smuggling. HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Transfer encoding header parsing which could allow for CL:TE or TE:TE attacks.
{	  "affected_product": {	    "package_name": "netius",	    "github_url": "",	    "fix_versions": ["1.17.58"],	    "affected_versions": ["prior to 1.17.58"],	    "version_intervals": []	  },	  "related_products": [],	  "vulnerability_type": "HTTP Request Smuggling",	  "vulnerability_type_details": "HTTP pipelining issues and request smuggling attacks might be possible due to incorrect Transfer encoding header parsing which could allow for CL:TE or TE:TE attacks.",	  "keywords": ["netius", "vulnerable", "HTTP Request Smuggling", "pipelining issues", "request smuggling attacks", "Transfer encoding header parsing", "CL:TE", "TE:TE attacks"],	  "code_info": {	    "vulnerable_file_names": [],	    "vulnerable_function_names": [],	    "vulnerable_component_names": [],	    "exception_names": [],	    "vulnerable_code_lines": [],	    "vulnerable_command_names": [],	    "parameters": []	  },	  "exploit_info": {	    "proof_of_concept": "",	    "privileges_required": "",	    "exploit_maturity": ""	  },	  "other_info": {	    "workaround": "",	    "product_description": "",	    "component_additional_info": "",	    "is_cve_disputed": "",	    "is_cve_rejected": "",	    "referenced_cve": []	  }	}

CVE-2020-7692
PKCE support is not implemented in accordance with the RFC for OAuth 2.0 for Native Apps. Without the use of PKCE, the authorization code returned by an authorization server is not enough to guarantee that the client that issued the initial authorization request is the one that will be authorized. An attacker is able to obtain the authorization code using a malicious app on the client-side and use it to gain authorization to the protected resource. This affects the package com.google.oauth-client:google-oauth-client before 1.31.0.
{	    "affected_product": {	        "package_name": "com.google.oauth-client:google-oauth-client",	        "github_url": "https://github.com/google/google-oauth-client",	        "fix_versions": [],	        "affected_versions": ["1.31.0"],	        "version_intervals" : []	    },	    "related_products": [],	    "vulnerability_type": "Authorization Bypass",	    "vulnerability_type_details": "PKCE support is not implemented",	    "keywords": ["PKCE", "OAuth 2.0", "Native Apps", "authorization code", "attacker", "malicious app"],	    "code_info": {	        "vulnerable_file_names" : [],	        "vulnerable_function_names": [],	        "vulnerable_component_names": [],	        "exception_names": [],	        "vulnerable_code_lines": [],	        "vulnerable_command_names": [],	        "parameters": []	    },	    "exploit_info": {	        "proof_of_concept": "",	        "privileges_required": "",	        "exploit_maturity": ""	    },	    "other_info": {	        "workaround": "",	        "product_description": "",	        "component_additional_info": "",	        "is_cve_disputed": "",	        "is_cve_rejected" : "",	        "referenced_cve": []	    }	}

CVE-2020-7694
This affects all versions of package uvicorn. The request logger provided by the package is vulnerable to ASNI escape sequence injection. Whenever any HTTP request is received, the default behaviour of uvicorn is to log its details to either the console or a log file. When attackers request crafted URLs with percent-encoded escape sequences, the logging component will log the URL after it's been processed with urllib.parse.unquote, therefore converting any percent-encoded characters into their single-character equivalent, which can have special meaning in terminal emulators. By requesting URLs with crafted paths, attackers can: * Pollute uvicorn's access logs, therefore jeopardising the integrity of such files. * Use ANSI sequence codes to attempt to interact with the terminal emulator that's displaying the logs (either in real time or from a file).
{	"affected_product": {	"package_name": "uvicorn",	"github_url": "",	"fix_versions": [],	"affected_versions": ["all"],	"version_intervals" : []	},	"related_products": [],	"vulnerability_type": "ASNI escape sequence injection",	"vulnerability_type_details": "",	"keywords": ["uvicorn", "request logger", "ASNI escape sequence injection", "HTTP request", "percent-encoded escape sequences", "logging component", "urllib.parse.unquote", "crafted URLs", "pollute access logs", "ANSI sequence codes", "terminal emulator"],	"code_info": {	"vulnerable_file_names" : [],	"vulnerable_function_names": [],	"vulnerable_component_names": [],	"exception_names": [],	"vulnerable_code_lines": [],	"vulnerable_command_names": [],	"parameters": []	},	"exploit_info": {	"proof_of_concept": "",	"privileges_required": "",	"exploit_maturity": ""	},	"other_info": {	"workaround": "",	"product_description": "",	"component_additional_info": "",	"is_cve_disputed": "",	"is_cve_rejected" : "",	"referenced_cve": []	}	}

CVE-2020-7695
Uvicorn before 0.11.7 is vulnerable to HTTP response splitting. CRLF sequences are not escaped in the value of HTTP headers. Attackers can exploit this to add arbitrary headers to HTTP responses, or even return an arbitrary response body, whenever crafted input is used to construct HTTP headers.
{	  "affected_product": {	    "package_name": "Uvicorn",	    "github_url": "",	    "fix_versions": ["0.11.7"],	    "affected_versions": ["before 0.11.7"],	    "version_intervals": []	  },	  "related_products": [],	  "vulnerability_type": "HTTP response splitting",	  "vulnerability_type_details": "CRLF sequences are not escaped in the value of HTTP headers. Attackers can exploit this to add arbitrary headers to HTTP responses, or even return an arbitrary response body, whenever crafted input is used to construct HTTP headers.",	  "keywords": ["Uvicorn", "vulnerable", "HTTP response splitting", "CRLF sequences", "HTTP headers", "attackers", "arbitrary headers", "response body", "crafted input"],	  "code_info": {	    "vulnerable_file_names": [],	    "vulnerable_function_names": [],	    "vulnerable_component_names": [],	    "exception_names": [],	    "vulnerable_code_lines": [],	    "vulnerable_command_names": [],	    "parameters": []	  },	  "exploit_info": {	    "proof_of_concept": "",	    "privileges_required": "",	    "exploit_maturity": ""	  },	  "other_info": {	    "workaround": "",	    "product_description": "",	    "component_additional_info": "",	    "is_cve_disputed": "",	    "is_cve_rejected": "",	    "referenced_cve": []	  }	}

CVE-2020-7698
This affects the package Gerapy from 0 and before 0.9.3. The input being passed to Popen, via the project_configure endpoint, isn’t being sanitized.
{	  "affected_product": {	    "package_name": "Gerapy",	    "github_url": "",	    "fix_versions": [],	    "affected_versions": ["0", "0.9.3"],	    "version_intervals": []	  },	  "related_products": [],	  "vulnerability_type": "",	  "vulnerability_type_details": "",	  "keywords": ["Gerapy", "package", "Popen", "project_configure", "sanitized"],	  "code_info": {	    "vulnerable_file_names": [],	    "vulnerable_function_names": [],	    "vulnerable_component_names": [],	    "exception_names": [],	    "vulnerable_code_lines": [],	    "vulnerable_command_names": [],	    "parameters": []	  },	  "exploit_info": {	    "proof_of_concept": "",	    "privileges_required": "",	    "exploit_maturity": ""	  },	  "other_info": {	    "workaround": "",	    "product_description": "",	    "component_additional_info": "",	    "is_cve_disputed": "",	    "is_cve_rejected": "",	    "referenced_cve": []	  }	}

CVE-2021-21241
The Python "Flask-Security-Too" package is used for adding security features to your Flask application. It is an is a independently maintained version of Flask-Security based on the 3.0.0 version of Flask-Security. In Flask-Security-Too from version 3.3.0 and before version 3.4.5, the /login and /change endpoints can return the authenticated user's authentication token in response to a GET request. Since GET requests aren't protected with a CSRF token, this could lead to a malicious 3rd party site acquiring the authentication token. Version 3.4.5 and version 4.0.0 are patched. As a workaround, if you aren't using authentication tokens - you can set the SECURITY_TOKEN_MAX_AGE to "0" (seconds) which should make the token unusable.
{	"affected_product": {	"package_name": "Flask-Security-Too",	"github_url": "",	"fix_versions": ["3.4.5", "4.0.0"],	"affected_versions": ["3.3.0"],	"version_intervals" : [[3.3.0,3.4.5]]	},	"related_products": [ ],	"vulnerability_type": "CSRF token vulnerability",	"vulnerability_type_details": "",	"keywords": ["Python", "Flask", "Flask-Security-Too", "security", "authentication", "token", "GET request", "CSRF token"],	"code_info": {	"vulnerable_file_names" : [""],	"vulnerable_function_names": [""],	"vulnerable_component_names": [""],	"exception_names": [""],	"vulnerable_code_lines": [""],	"vulnerable_command_names": [""],	"parameters": [""],	},	"exploit_info": {	"proof_of_concept": "",	"privileges_required": "",	"exploit_maturity": ""	},	"other_info": {	"workaround": "Set SECURITY_TOKEN_MAX_AGE to \"0\" (seconds)",	"product_description": "",	"component_additional_info": "",	"is_cve_disputed": "",	"is_cve_rejected" : "",	"referenced_cve": []	}	}
a